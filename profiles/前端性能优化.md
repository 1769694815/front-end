## 为什么要进行性能优化
* 用户: 提升用户体验，改善页面性能
* 开发者: 体现公司意志和开发人员技能

## 性能优化的总体方向
* 高效 ：合理安排资源
* 快速 ：减少等待时间

## 优化方向
### HTML/CSS优化
* 能用html/css解决的问题就不要用js
	* 更快的开发速度，更小的维护成本
	* eg:导航高亮、鼠标悬停
	
	```
	nav li {
		opacity: 0.5;
	}
	nav li:hover {
		opacity: 1;
	}
	```
	```
	.menu {
		display: none;
	}
	.nav:hover + .menu {
		display: inline-block;
	}
	.menu:before {
		content: '';
		position: absolute;
		top: -20px;
		left: 0px;
		width: 100%;
		height: 20px;
	```

	* 自定义样式与css伪类
		* 使用全局样式sass、scss
		
		`:focus`
		`input[type=checkbox]:checked{}`
		`max-width`
	
* 优化HTML标签
	* 文字`<p>``<h1>`减少css代码
	* 表单`<form>`
	* 列表`<ol>``<ul>`
	* 图片`<img>``<picture>`
	* 链接`<a>``<button>`
	* 根据情况使用input type值
	* 使用HTML5语义化标签
	
	```
	<nav></nav>
	<header></header>
	<main>
		<section></section>
		<section></section>
	</main>
	<footer></footer>
	```

### js优化
* 减少前端代码耦合
	* 利用策略模式抽离公共组件、参数、封装请求
* js书写优化
	* 按照强类型风格去写代码，指明变量类型和返回类型
	
	```
	getPrice:function(price){
		if (price < 0) {
			return false;
		}else {
			return price * 10
		}
	}
	getPrice:function(price){
		if (price < 0) {
			return -1;
		}else {
			return price * 10
		}
	}
	//类型确定，解析器不会去做一些额外的的工作
	//优化回滚：编译器已经编译完成函数，类型变化导致回滚到通用状态，重新生成函数
	```
	
	* 减少作用域查找，尽量少的不要让代码暴露在全局作用域下
	
	```
	<script>
		var map = document.querySelector('#imap');
		map.style.height = '10px';
	</script>
	<script>
		!function() {
			var map = document.querySelector('#imap');
			map.style.height = '10px';
		}
	</script>
	```
	
	* 避免 == 的使用
		* 确定类型的情况下直接使用===
* 使用ES6简化代码

### 页面加载速度优化
* 页面加载之前都经历了什么
	* DNS服务器通过域名查找对应的web服务器的ip地址
	* 三次握手机制、四次挥手机制
	* HTTP请求
	* 返回资源
* 页面渲染过程优化(例)
	 ![页面加载过程](../images/页面加载过程.png)
	* JavaScript=>Style=>Layout=>Paint=>Composite=>reflow?=>repaint?

	```
	> (1)display:none 的节点不会被加入Render Tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。
	> (2)display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。
	> (3)有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。
	```

	* dom深度尽量浅
	* 减少行内css和js的使用
	* 合适的选择器，避免后代选择器，通配符选择器
	* 异步加载js文件并合并js文件
* 加快页面的打开速度

	> 页面开启速度主要指标：白屏时间，首屏时间，页面加载完成时间，所有资源加载完成(例)
	* 减少渲染堵塞(js、css 例)
	* 延时加载图片，按需加载
	* 压缩和缓存(例)
		* gzip压缩、Cache-control、Etag
* 增强用户体验

### 应用、网络传输层优化
* [三次握手](./chorme浏览器.md)
* 假设一个典型的宽带环境
	* 没有本地缓存
	* 相对较快的DNS解析(50ms)，TCP握手，ssl协商
	* 较快的服务器响应时间(100ms)
	* 一次延迟(80ms)
* 网络传输层时间分析
	* 50ms for DNS
	* 80ms for TCP handshake (one RTT)
	* 160ms for SSL handshake (two RTT's)
	* 40ms （发送请求到服务器）
	* 100ms (服务器处理)
	* 40ms (服务器回传响应数据)
	* 一个请求耗费470ms，事实上，470ms已经很乐观了
* 优化缓存性能

	> 最快的请求就是没有请求
	* Expires, ETag, Last-Modified和Cache-Control
	* chorme有两种内部缓存的实现：本地磁盘和内存
	* 内存模式主要应用于无痕浏览，在窗口关闭时清除掉
	* 磁盘缓存实现了它自己的一组数据结构, 它们被存储在一个单独的缓存目录里。其中有索引文件(在浏览器启动时加载到内存中)，数据文件(存储着实际数据，以及HTTP头以及其它信息)
	* [查看缓存存储的数据和响应处理](chrome://net-internals/#httpCache)
	* [DNS度量数据](chrome://histograms/DNS)
	* [DNS预解析](chrome://DNS)


### Vue和webpack性能优化
> vue 的性能已经很强大了

* v-show，v-if 的使用
* 尽量不使用 float 布局，可以用flex或者grid布局
* 慎用deep watch
* [vue-router](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html)
* 减少不必要的依赖包
* 

* [雅虎的性能优化](https://developer.yahoo.com/performance/rules.html?guccounter=1)

### 用好Chrome Devtools
###区分代码优化、HTTP优化、网页加载优化
* 使用icon代替各种图片
* input组件开发利用html5属性148
* chorme浏览器同域最多发送6个tcp请求164  可更改